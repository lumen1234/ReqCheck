# 功能设计

1. 文档上传功能
2. 需求按照MEMS需求规格说明，基于一级标题、二级标题，构造需求树。根节点应当是文档名，一级节点的label应当是来自于各个一级标题，如果一级标题下没有所属的二级标题，这content就是这个一级标题下的内容，该一级节点本身即为叶子结点；若一级标题下有二级标题，这content为null，该一级节点也有所属的二级结点。二级节点的label应当是来自于二级标题，该树的最大深度为2，因此二级结点的content为二级标题的所有内容。
   - 总体需求
    - 范围
    - 引用文档
    - 需求
      - 要求的状态和方式
      - 能力需求
        - 工作流程（叶子节点）
3. 首先预处理好438C的各个附录，附录J用于验证“需求规格说明”，其他附录用于验证其他需求文档。需求文档有很多种，建议用户上传文档的时候，就标明文档是什么类型的，直接使用对应的附录来对文档进行验证。目前可以只支持“需求规格说明”的验证
4. 根据1.提取的需求树的各个节点，都应当与附录J对应，将对应的规则与内容输入给大模型，要求大模型判断是否合规
5. 需求补全功能优先级暂缓，具体实现方式是将需求文档正文发给大模型，告诉大模型补充空缺处（1.2），并将1.2的撰写要求（附录J的对应条目）一并发给大模型，对于不能补充的部分，让大模型空着或者标注出来（<EMPTY>）
6. 迭代的目标是将补全后文档重新从3开始走一遍，检查文档是否合规
7. 可导出分条的JSON格式需求

# 具体实现逻辑示例
## 文档上传功能
让大模型构造一个接口，接收网络的txt或docx格式的文件的上传，并在本地存储，保存文档id，上传时要指定文档类型（《需求规格说明》、xxxx）
## 需求拆解
1. 基于word的解析库docx，解析上传上来的文档，并提取每个标题的级别、编号、标题内容、标题下的所有子内容
2. 根据解析的标题级别，构造需求树
3. 实现接口，当用户指定特定文档时，对文档进行1、2的操作，并返回需求树的JSON
## 需求验证
1. 首先需要存储特定的附录，并标明它是用于规范哪类文档的。
2. 需要拆解附录J，将每一项标题、要求单独存储，应当是一个规则树
3. 在实际验证时，根据前端传来的文件ID，确认其文档类型（需求规格说明），然后选取对应的附录
4. 根据拆解后的文档，基于标题号逐条的找到对应的规则，将标题号及其对应的内容+对应的规则一起发给大模型，prompt如下：
   你是一个文档审查专家，如下是一组文档规范及对应的文档内容。请你根据规范，判断文档内容是否符合规范，返回一个JSON，JSON格式应当如下，用result（bool）标明是否合规，用reason（String）简要说明判断的依据：
   ```json
   {
    "result":false,
    "reason":"这个需求没有说明需求的具体数值"
   }
   ```
   # 文档规范
   {{RULE}}
   # 文档内容
   {{CONTENT}}
5. 在执行需求验证时，需要逐项判断（最好给前端同步进度），并在完成执行后，将执行结果发给前端。具体的发送内容应当是一个数组，包括了每一项需求的id、是否合规、不合规的reason、需求的父节点id
## 需求补全
先不实现
## 迭代
先不实现
## 需求导出
1. 针对于切分后的需求（来自“需求拆解”），前端需要提供导出功能

# 后续工作安排
1. 由龙星宇负责后端实现，有问题时联系仝羽翔、康宇翔，线上讨论开会决定
2. 由康宇翔负责前端实现，首先完成功能流程的梳理，并按照张言强提供的前端设计文档，按需参考原有的需求验证工具前端，完成前端构建
3. 由龙星宇提供接口文档，后续由康宇翔完成前端接口部分对接，具体接口格式尽量按照前文设计来
4. 前后端功能完成后，发给孙中杰完成docker镜像打包